{"mode":"Text","hardwareTarget":"brain","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START IQ MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END IQ MACROS\n\n\n// Robot configuration code.\ninertial BrainInertial = inertial();\ncontroller Controller = controller();\nmotor armmMotorA = motor(PORT1, true);\nmotor armmMotorB = motor(PORT7, false);\nmotor_group armm = motor_group(armmMotorA, armmMotorB);\n\nmotor LM = motor(PORT8, false);\nmotor RM = motor(PORT2, true);\nmotor ptoR = motor(PORT3, true);\nmotor ptoL = motor(PORT9, false);\npneumatic pto_Lclaw = pneumatic(PORT5);\npneumatic beam_rclaw = pneumatic(PORT11);\ndistance Rdis = distance(PORT4);\ndistance Ldis = distance(PORT10);\ntouchled TouchLED12 = touchled(PORT12);\n\n\n// generating and setting random seed\nvoid initializeRandomSeed(){\n  wait(100,msec);\n  double xAxis = BrainInertial.acceleration(xaxis) * 1000;\n  double yAxis = BrainInertial.acceleration(yaxis) * 1000;\n  double zAxis = BrainInertial.acceleration(zaxis) * 1000;\n  // Combine these values into a single integer\n  int seed = int(\n    xAxis + yAxis + zAxis\n  );\n  // Set the seed\n  srand(seed); \n}\n\n\n\nvoid vexcodeInit() {\n\n  // Initializing random seed.\n  initializeRandomSeed(); \n}\n\n\n// define variable for remote controller enable/disable\nbool RemoteControlCodeEnabled = true;\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n// Include the IQ Library\n#include \"vex.h\"\n  \n// Allows for easier use of the VEX Library\nusing namespace vex;\n\n// User defined function\nvoid blue121auto();\n// User defined function\nvoid red121auto();\n// User defined function\nvoid fangsanjiao();\n// User defined function\nvoid chas(double Lspeed, double Rspeed);\n// User defined function\nvoid ptoLR(double ptoL, double ptoR);\nvoid turnto(int deg);\nfloat  cha, chc, pto_chas, ctchas, ctrclaw, ctlclaw, ctclaw, ctbeam, tri, E, Edownpos, teamcolor;\ndouble err,integ,deri,lasterr,pid;int count;\nvoid turnto(int deg)\n{\n  count=0;\n  err=deg-BrainInertial.rotation(degrees);\n  while(1)\n  {\n    if(fabs(err)<3)\n    {\n      count+=1;\n      if(count>40||(fabs(err)<20&&fabs(Controller.AxisC.position())>30))\n        {break;}\n    }\n    err=deg-BrainInertial.rotation(degrees);\n    if(fabs(err)>5&&fabs(err)<30)\n    {\n      integ=integ+=err;\n    }\n    deri=err-lasterr;\n    pid=err*0.5+integ*0.002+deri*0.8;\n    if(fabs(pid)>55)\n    {\n      pid=55*pid/fabs(pid);\n    }\n    chas(pid,-pid);\n    lasterr=err;\n    wait(8,msec);\n  }\n}\n// User defined function\nvoid blue121auto() {\n  ptoR.setStopping(coast);\n  ptoL.setStopping(coast);\n  pto_Lclaw.retract(cylinder1);\n  wait(0.2, seconds);\n  LM.setPosition(0.0, degrees);\n  chas(-70.0, -70.0);\n  ptoLR(-70.0, -70.0);\n  waitUntil((LM.position(degrees) < -70.0));\n  pto_chas = 3.0;\n  ptoR.setStopping(hold);\n  ptoL.setStopping(hold);\n  ptoR.spin(forward);\n  ptoL.spin(forward);\n  ptoLR(-100.0, -100.0);\n  RM.setPosition(0.0, degrees);\n  LM.setStopping(hold);\n  RM.setStopping(hold);\n  BrainInertial.setRotation(0,degrees);\n  turnto(168);\n  chas(0.0, 0.0);\n  wait(0.2, seconds);\n  pto_chas = 0.0;\n}\n\n// User defined function\nvoid red121auto() {\n  ptoR.setStopping(coast);\n  ptoL.setStopping(coast);\n  pto_Lclaw.retract(cylinder1);\n  wait(0.2, seconds);\n  LM.setPosition(0.0, degrees);\n  chas(-70.0, -70.0);\n  ptoLR(-70.0, -70.0);\n  waitUntil((LM.position(degrees) < -70.0));\n  pto_chas = 3.0;\n  ptoR.setStopping(hold);\n  ptoL.setStopping(hold);\n  ptoR.spin(forward);\n  ptoL.spin(forward);\n  ptoLR(-100.0, -100.0);\n  LM.setPosition(0.0, degrees);\n  LM.setStopping(hold);\n  RM.setStopping(hold);\n  BrainInertial.setRotation(0,degrees);\n  turnto(-168);\n  chas(0.0, 0.0);\n  wait(0.6, seconds);\n  pto_chas = 0.0;\n}\n\n// User defined function\nvoid fangsanjiao() {\n  tri = 1.0;\n  ctchas = 0.0;\n  chas(80.0, 80.0);\n  ptoLR(80.0, 80.0);\n  wait(0.3, seconds);\n  armm.setVelocity(90.0, percent);\n  armm.spinToPosition(10.0, degrees, false);\n  wait(0.2, seconds);\n  pto_Lclaw.retract(cylinder2);\n  beam_rclaw.retract(cylinder2);\n  wait(0.3, seconds);\n  chas(-80.0, -80.0);\n  ptoLR(-80.0, -80.0);\n  wait(0.3, seconds);\n  ctchas = 1.0;\n  armm.spinToPosition(0.0, degrees, true);\n  tri = 0.0;\n}\n\n// User defined function\nvoid chas(double Lspeed, double Rspeed) {\n  LM.spin(forward);\n  RM.spin(forward);\n  LM.setVelocity(Lspeed, percent);\n  RM.setVelocity(Rspeed, percent);\n}\n\n// User defined function\nvoid ptoLR(double ptoLs, double ptoRs) {\n  ptoL.spin(forward);\n  ptoR.spin(forward);\n  ptoL.setVelocity(ptoLs, percent);\n  ptoR.setVelocity(ptoRs, percent);\n}\n\n// \"when started\" hat block\nint whenStarted1() {\n  Edownpos = 92.0;\n  armm.setStopping(hold);\n  beam_rclaw.retract(cylinder1);\n  ctclaw = 0.0;\n  ctbeam = 0.0;\n  tri = 0.0;\n  while (true) {\n    if (Controller.ButtonRUp.pressing()) {\n      if (pto_chas == 0.0) {\n        ptoR.setStopping(hold);\n        ptoL.setStopping(hold);\n        ptoR.spin(forward);\n        ptoL.spin(forward);\n        ptoR.setVelocity(-100.0, percent);\n        ptoL.setVelocity(-100.0, percent);\n      }\n      else {\n        if (fmod(ctbeam,2.0) == 1.0) {\n          ctchas = 0.0;\n          chas(0.0, 0.0);\n          ptoLR(0.0, 0.0);\n          wait(0.3, seconds);\n          ptoR.setStopping(coast);\n          ptoL.setStopping(coast);\n          pto_Lclaw.retract(cylinder1);\n          pto_chas = 0.0;\n          wait(0.2, seconds);\n          ptoR.setPosition(0.0, degrees);\n          ctchas = 1.0;\n        }\n      }\n    }\n    else {\n      if (Controller.ButtonRDown.pressing()) {\n        if (pto_chas == 1.0) {\n          pto_chas = 0.0;\n          ctchas = 0.0;\n          chas(0.0, 0.0);\n          ptoLR(0.0, 0.0);\n          wait(0.1, seconds);\n          pto_Lclaw.retract(cylinder1);\n          ptoR.setStopping(coast);\n          ptoL.setStopping(coast);\n          wait(0.2, seconds);\n          ctchas = 1.0;\n          ptoR.setStopping(brake);\n          ptoL.setStopping(brake);\n          ptoR.spin(forward);\n          ptoL.spin(forward);\n          ptoR.setVelocity(90.0, percent);\n          ptoL.setVelocity(90.0, percent);\n          wait(0.3, seconds);\n          waitUntil((fabs(static_cast<float>(ptoR.velocity(rpm))) < 5.0));\n          ptoR.stop();\n          ptoL.stop();\n          ptoR.setPosition(0.0, degrees);\n          ptoL.setPosition(0.0, degrees);\n        }\n        ptoR.spin(forward);\n        ptoL.spin(forward);\n        ptoR.setVelocity(80.0, percent);\n        ptoL.setVelocity(80.0, percent);\n      }\n      else {\n        if (pto_chas == 0.0) {\n          ptoR.setVelocity(0.0, percent);\n          ptoL.setVelocity(0.0, percent);\n        }\n      }\n    }\n    if (Controller.ButtonFUp.pressing()) {\n      while (Controller.ButtonFUp.pressing()) {\n      wait(20, msec);\n      }\n      ctbeam = ctbeam + 1.0;\n      if (fmod(ctbeam,2.0) == 1.0) {\n        ctchas = 0.0;\n        pto_chas = 0.0;\n        chas(-40.0, -40.0);\n        wait(0.3, seconds);\n        beam_rclaw.extend(cylinder1);\n        wait(0.1, seconds);\n        chas(0.0, 0.0);\n        wait(0.2, seconds);\n        ptoR.setStopping(coast);\n        ptoR.setStopping(coast);\n        pto_Lclaw.extend(cylinder1);\n        ptoR.setPosition(0.0, degrees);\n        wait(0.2, seconds);\n        ctchas = 1.0;\n        pto_chas = 1.0;\n      }\n      else {\n        if (ptoR.position(degrees) < -380.0) {\n          ptoLR(0.0, 0.0);\n          beam_rclaw.retract(cylinder1);\n          RM.setPosition(0.0, degrees);\n          LM.setPosition(0.0, degrees);\n          waitUntil(((LM.position(degrees) > 90.0 || RM.position(degrees) > 90.0) || Controller.ButtonFUp.pressing()));\n          ptoLR(0.0, 0.0);\n          ptoR.setStopping(coast);\n          ptoR.setStopping(coast);\n          pto_Lclaw.extend(cylinder1);\n          pto_chas = 1.0;\n        }\n        else {\n          if (ptoR.position(degrees) < -100.0) {\n            ptoLR(0.0, 0.0);\n            beam_rclaw.retract(cylinder1);\n            LM.setPosition(0.0, degrees);\n            RM.setPosition(0.0, degrees);\n            waitUntil(((LM.position(degrees) > 90.0 || RM.position(degrees) > 90.0) || Controller.ButtonFUp.pressing()));\n            ptoR.setStopping(coast);\n            ptoR.setStopping(coast);\n            pto_Lclaw.extend(cylinder1);\n            pto_chas = 1.0;\n          }\n          else {\n            ptoLR(0.0, 0.0);\n            beam_rclaw.retract(cylinder1);\n            LM.setPosition(0.0, degrees);\n            RM.setPosition(0.0, degrees);\n            waitUntil(((LM.position(degrees) > 90.0 || RM.position(degrees) > 90.0) || Controller.ButtonFUp.pressing()));\n            ptoR.setStopping(coast);\n            ptoR.setStopping(coast);\n            pto_Lclaw.extend(cylinder1);\n            pto_chas = 1.0;\n          }\n        }\n      }\n    }\n    if (Controller.ButtonEUp.pressing()) {\n      while (Controller.ButtonEUp.pressing()) {\n      wait(20, msec);\n      }\n      if (ctclaw == 0.0 && (ctlclaw == 0.0 && ctrclaw == 0.0)) {\n        beam_rclaw.extend(cylinder2);\n        pto_Lclaw.extend(cylinder2);\n        ctclaw = 1.0;\n      }\n      else {\n        beam_rclaw.retract(cylinder2);\n        pto_Lclaw.retract(cylinder2);\n        wait(0.5, seconds);\n        ctclaw = 0.0;\n      }\n    }\n    if (tri == 0.0 && ((armm.position(degrees) < 20.0 && ctclaw == 0.0) && !Controller.ButtonLUp.pressing())) {\n      if (Rdis.objectDistance(mm) < 85.0 && !Controller.ButtonLDown.pressing()) {\n        beam_rclaw.extend(cylinder2);\n        ctrclaw = 1.0;\n      }\n      else {\n        beam_rclaw.retract(cylinder2);\n        ctrclaw = 0.0;\n      }\n      if (Ldis.objectDistance(mm) < 85.0 && !Controller.ButtonLDown.pressing()) {\n        pto_Lclaw.extend(cylinder2);\n        ctlclaw = 1.0;\n      }\n      else {\n        pto_Lclaw.retract(cylinder2);\n        ctlclaw = 0.0;\n      }\n    }\n    else {\n    }\n  wait(20, msec);\n  }\n  return 0;\n}\n\n// \"when started\" hat block\nint whenStarted2() {\n  armm.spin(forward);\n  armm.setVelocity(-50.0, percent);\n  wait(0.3, seconds);\n  waitUntil((fabs(static_cast<float>(armm.velocity(percent))) < 5.0));\n  armm.setStopping(brake);\n  armm.stop();\n  wait(0.2, seconds);\n  armm.setPosition(-6.0, degrees);\n  while (true) {\n    if (70.0 < armm.position(degrees) < 120.0) {\n      if (Controller.AxisD.position() > 90.0) {\n        pto_Lclaw.extend(cylinder2);\n        beam_rclaw.extend(cylinder2);\n        wait(0.2, seconds);\n        armm.setVelocity(90.0, percent);\n        armm.spinToPosition(162.0, degrees, true);\n      }\n    }\n    if (Controller.ButtonR3.pressing()) {\n      if (armm.position(degrees) < 100.0) {\n        tri = 1.0;\n        armm.setVelocity(90.0, percent);\n        armm.spinToPosition(245.0, degrees, true);\n        armm.setStopping(hold);\n        tri = 0.0;\n      }\n      else {\n        if (armm.position(degrees) > 180.0) {\n          ctchas = 0.0;\n          chas(70.0, 70.0);\n          if (pto_chas == 1.0) {\n            ptoLR(70.0, 70.0);\n          }\n          wait(0.3, seconds);\n          LM.setStopping(coast);\n          RM.setStopping(coast);\n          chas(0.0, 0.0);\n          if (pto_chas == 1.0) {\n            ptoLR(0.0, 0.0);\n          }\n          armm.setVelocity(90.0, percent);\n          armm.spinToPosition(Edownpos, degrees, false);\n          pto_Lclaw.retract(cylinder2);\n          beam_rclaw.retract(cylinder2);\n          wait(0.2, seconds);\n          if (fmod(teamcolor,2.0) == 0.0) {\n            red121auto();\n          }\n          else {\n            blue121auto();\n          }\n          ctchas = 1.0;\n        }\n      }\n    }\n    if (Controller.ButtonEDown.pressing()) {\n      if (armm.position(degrees) < 66.0) {\n        tri = 1.0;\n        armm.setStopping(hold);\n        armm.setTimeout(2.0, seconds);\n        if(Ldis.objectDistance(mm)<85||Rdis.objectDistance(mm)<85)\n        {\n          armm.spinToPosition(Edownpos, degrees, true);\n        }\n        else \n        {\n          armm.spinToPosition(75, degrees, true);\n        }\n        tri = 0.0;\n      }\n      else {\n      }\n    }\n    if (Controller.ButtonLUp.pressing()) {\n      if (fmod(ctbeam,2.0) == 1.0&&armm.position(degrees) < 30.0 && ((Rdis.objectDistance(mm) < 82.0 && Ldis.objectDistance(mm) < 82.0) && (ctlclaw == 1.0 && ctrclaw == 1.0))) {\n        pto_Lclaw.extend(cylinder2);\n        beam_rclaw.extend(cylinder2);\n        wait(0.2, seconds);\n        armm.spin(forward);\n        armm.setVelocity(80.0, percent);\n        armm.setTimeout(4.0, seconds);\n        armm.spinToPosition(540.0, degrees, true);\n        wait(0.1, seconds);\n        pto_Lclaw.retract(cylinder2);\n        beam_rclaw.retract(cylinder2);\n        armm.spinToPosition(-8.0, degrees, true);\n        ctlclaw = 0.0;\n        ctrclaw = 0.0;\n      }\n      while (Controller.ButtonLUp.pressing()) {\n        armm.setStopping(hold);\n        armm.spin(forward);\n        armm.setVelocity((100.0 - armm.position(degrees) / 20.0), percent);\n      wait(20, msec);\n      }\n    }\n    else {\n      if (Controller.ButtonLDown.pressing() && armm.position(degrees) > 0.0) {\n        armm.spin(forward);\n        armm.setStopping(brake);\n        armm.setVelocity(-100.0, percent);\n      }\n      else {\n        armm.stop();\n      }\n    }\n    if (Controller.ButtonFDown.pressing()) {\n      if (armm.position(degrees) < 140.0) {\n        tri = 1.0;\n        armm.setVelocity(100.0, percent);\n        armm.setStopping(hold);\n        armm.setTimeout(2.0, seconds);\n        armm.spinToPosition(158.0, degrees, true);\n        tri = 0.0;\n      }\n      else {\n        if (Rdis.objectDistance(mm) < 85.0 && Ldis.objectDistance(mm) < 85.0) {\n          tri = 1.0;\n          armm.spin(forward);\n          armm.setVelocity(-65.0, percent);\n          armm.setStopping(brake);\n          waitUntil((armm.position(degrees) < 115.0));\n          pto_Lclaw.retract(cylinder2);\n          beam_rclaw.retract(cylinder2);\n          armm.setVelocity(-100.0, percent);\n          waitUntil((armm.position(degrees) < 20.0));\n          pto_Lclaw.extend(cylinder2);\n          beam_rclaw.extend(cylinder2);\n          wait(0.2, seconds);\n          tri = 0.0;\n        }\n        else {\n          if (Rdis.objectDistance(mm) < 85.0) {\n            tri = 1.0;\n            armm.spin(forward);\n            armm.setVelocity(-65.0, percent);\n            armm.setStopping(brake);\n            waitUntil((armm.position(degrees) < 115.0));\n            beam_rclaw.retract(cylinder2);\n            armm.setVelocity(-100.0, percent);\n            waitUntil((armm.position(degrees) < 20.0));\n            pto_Lclaw.extend(cylinder2);\n            beam_rclaw.extend(cylinder2);\n            wait(0.2, seconds);\n            tri = 0.0;\n          }\n          else {\n            if (Ldis.objectDistance(mm) < 85.0) {\n              tri = 1.0;\n              armm.spin(forward);\n              armm.setVelocity(-65.0, percent);\n              armm.setStopping(brake);\n              waitUntil((armm.position(degrees) < 115.0));\n              pto_Lclaw.retract(cylinder2);\n              armm.setVelocity(-100.0, percent);\n              waitUntil((armm.position(degrees) < 20.0));\n              pto_Lclaw.extend(cylinder2);\n              beam_rclaw.extend(cylinder2);\n              wait(0.2, seconds);\n              tri = 0.0;\n            }\n          }\n        }\n      }\n    }\n  wait(20, msec);\n  }\n  return 0;\n}\n\n// \"when started\" hat block\nint whenStarted3() {\n  teamcolor = 0.0;\n  while (true) {\n    if (TouchLED12.pressing()) {\n      waitUntil((!TouchLED12.pressing()));\n      teamcolor = teamcolor + 1.0;\n    }\n    if (fmod(teamcolor,2.0) == 0.0) {\n      TouchLED12.setColor(red);\n    }\n    else {\n      TouchLED12.setColor(blue);\n    }\n    if (Brain.Battery.capacity(percent) < 60.0) {\n      Brain.playNote(3, 0, 500);\n      Brain.playNote(3, 1, 500);\n      Brain.playNote(3, 2, 500);\n      Brain.playNote(3, 0, 500);\n      Brain.playNote(3, 0, 500);\n      Brain.playNote(3, 1, 500);\n      Brain.playNote(3, 2, 500);\n      Brain.playNote(3, 0, 500);\n      Brain.playNote(3, 2, 500);\n      Brain.playNote(3, 3, 500);\n      Brain.playNote(3, 4, 500);\n      Brain.playNote(3, 2, 500);\n      Brain.playNote(3, 3, 500);\n      Brain.playNote(3, 4, 500);\n    }\n  wait(20, msec);\n  }\n  return 0;\n}\n\n// \"when started\" hat block\nint whenStarted4() {\n  ctchas = 1.0;\n  pto_chas = 1.0;\n  pto_Lclaw.extend(cylinder1);\n  LM.setStopping(brake);\n  RM.setStopping(brake);\n  while (true) {\n    if (ctchas == 1.0) {\n      if (fabs(static_cast<float>(Controller.AxisA.position())) < 10.0) {\n        cha = 0.0;\n      }\n      else {\n        cha = (Controller.AxisA.position() - 10.0) * 0.98;\n      }\n      if (fabs(static_cast<float>(Controller.AxisC.position())) < 10.0) {\n        chc = 0.0;\n      }\n      else {\n        if (pto_chas == 1.0) {\n          chc = (Controller.AxisC.position() - 10.0) * 0.55;\n        }\n        else {\n          chc = (Controller.AxisC.position() - 10.0) * 0.66;\n        }\n      }\n      chas(cha + chc, cha - chc);\n      if (pto_chas == 1.0) {\n        ptoLR(cha + chc, cha - chc);\n      }\n    }\n  wait(20, msec);\n  }\n  return 0;\n}\n\n// \"when started\" hat block\nint whenStarted5() {\n  while (true) {\n    if (ctchas == 1.0) {\n      if (fabs(static_cast<float>(Controller.AxisC.position())) > 15.0) {\n        Brain.Timer.reset();\n      }\n      if (Brain.Timer.value() > 0.4 && 70.0 < armm.position(degrees) < 260.0) {\n        LM.setStopping(coast);\n        RM.setStopping(coast);\n        if (pto_chas == 1.0) {\n          ptoR.setStopping(coast);\n          ptoL.setStopping(coast);\n        }\n      }\n      else {\n        LM.setStopping(brake);\n        RM.setStopping(brake);\n        if (pto_chas == 1.0) {\n          ptoR.setStopping(brake);\n          ptoL.setStopping(brake);\n        }\n      }\n    }\n  wait(20, msec);\n  }\n  return 0;\n}\n\n\nint main() {\n  // Initializing Robot Configuration. DO NOT REMOVE!\n  vexcodeInit();\n\n  vex::task ws1(whenStarted2);\n  vex::task ws2(whenStarted3);\n  vex::task ws3(whenStarted4);\n  vex::task ws4(whenStarted5);\n  whenStarted1();\n}","textLanguage":"cpp","robotConfig":[{"port":[],"name":"Controller","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","e":"","eDir":"false","f":"","fDir":"false","l3r3":"","l3r3Dir":"false","drive":"none"},"triportSourcePort":22},{"port":[1,7],"name":"armm","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"向前","rev":"撤销","motor_a_reversed":"true","motor_b_reversed":"false"},"triportSourcePort":22},{"port":[8],"name":"LM","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"向前","rev":"撤销"},"triportSourcePort":22},{"port":[2],"name":"RM","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"向前","rev":"撤销"},"triportSourcePort":22},{"port":[3],"name":"ptoR","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"向前","rev":"撤销"},"triportSourcePort":22},{"port":[9],"name":"ptoL","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"向前","rev":"撤销"},"triportSourcePort":22},{"port":[5],"name":"pto_Lclaw","customName":true,"deviceType":"Pneumatic","deviceClass":"pneumatic","setting":{"cylinder1":"pto","cylinder2":"Lclaw","cylinder1_reversed":"false","cylinder2_reversed":"false"},"triportSourcePort":22},{"port":[11],"name":"beam_rclaw","customName":true,"deviceType":"Pneumatic","deviceClass":"pneumatic","setting":{"cylinder1":"beam","cylinder2":"Rlcaw","cylinder1_reversed":"false","cylinder2_reversed":"false"},"triportSourcePort":22},{"port":[4],"name":"Rdis","customName":true,"deviceType":"Distance","deviceClass":"distance","setting":{},"triportSourcePort":22},{"port":[10],"name":"Ldis","customName":true,"deviceType":"Distance","deviceClass":"distance","setting":{},"triportSourcePort":22},{"port":[12],"name":"TouchLED12","customName":false,"deviceType":"TouchLED","deviceClass":"touchled","setting":{},"triportSourcePort":22}],"slot":6,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"4.62.0","minVersion":"4.60.0","fileFormat":"2.0.0","targetBrainGen":"Second","v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null},"target":"Physical"}